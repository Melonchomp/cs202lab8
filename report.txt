Potential Edge Conditions: Running out of words, random function selects an index out of bounds, user types something
that is not a letter, invalid difficulty level chosen, player ends the game before playing.


Hangman(): This is our default constructor for the class. Just sets all variables to defualt values.

displayMan(): This will print out the noose, and the man in ascii art depending on how many
attempts the user has used.

startGame(): This is the function that will run the game and keep track of the word, chars used, attempts
left. The bulk of the actual gameplay.

Menu(): This prints out menu options such as: restart, end, difficulty level, stats

hints(): This will look through the vector of characters available, and whichever character it finds first
that is in the word it will insert it into the user's guesses at the cost of an attempt.

chooseWord( char ): The parameter given to this function, by the user, will be, E, M, or H, for easy, medium, hard, difficulty. This will randomly choose
a word inside one of the categories based on that difficulty.

Con: We aren't using all of the Class's capabilities because don't use new/delete. We could have performance issues
if we implement something improperly. Using object-oriented programming for our project could be
overcomplicating the solution.

Pros: Clarity, readability, easier to breakup. This is basically a TLDR of our code. Classes allow scalability, so we can continuously add to the Hangman game without
significantly changing the entire code.

The unordered_map is going to be useful to hold the words in each category. We are using a vector to hold the letters of the alphabet
to keep track of what the user has guessed.

Things to check for in rubric:
   corrrectly reads from words file
   correctly displays game
   well formated, commented
   game properly ends or starts a new round
   hints correctly decrements attempts
   displayMan correctly outputs the man, based on attempts and difficulty
   menu displays correct stats and options
   start game continuously runs until the user decides to end the game, and properly resets after each round
   Make sure that the character guessed is going in the correct spot.

Test case 1: Intentionally try invalid options to make sure program doesnt break
Test case 2: Play through a game and intentionally fail and check stats to make sure stats is properly accumulating
Test case 3: Play to win and make sure stats is counting the win
Test case 4: Replay game multiple times to make sure it is replayable
Test case 5: When changing between difficulty, attempts change to the corresponding value.